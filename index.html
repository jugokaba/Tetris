<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Tetris</title>
<style>
  html, body {
    margin:0; padding:0; height:100%;
    background:#111; color:white;
    font-family: sans-serif;
    display:flex; flex-direction: column; align-items: center; justify-content: flex-start;
    user-select: none;
  }
  h1 { margin: 10px 0; }
  #game-container {
    position: relative;
    width: 240px; /* 10 blocks * 24px */
    height: 480px; /* 20 blocks * 24px */
    border: 2px solid white;
    background: black;
  }
  canvas {
    display: block;
    image-rendering: pixelated;
    width: 100%;
    height: 100%;
  }
  #menu, #pauseOverlay, #gameOverOverlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border: 2px solid white;
    z-index: 10;
  }
  #info {
    margin-top: 10px;
    font-size: 18px;
    display: flex; justify-content: center; gap: 20px;
  }
  #controls {
    max-width: 300px;
    margin-top: 10px;
    font-size: 14px;
    text-align: left;
  }
  #highscores {
    max-height: 150px;
    overflow-y: auto;
    width: 100%;
    text-align: center;
  }
  button {
    cursor: pointer;
    font-size: 16px;
    margin-top: 10px;
    padding: 8px 16px;
    border: none;
    background: #222;
    color: white;
    border: 1px solid white;
    border-radius: 4px;
  }
  button:hover {
    background: #444;
  }
</style>
</head>
<body>
<h1>Tetris</h1>

<div id="game-container">
  <canvas id="tetris" width="240" height="480"></canvas>

  <div id="menu">
    <h2>Startmenü</h2>
    <button id="startBtn">Spiel Starten</button>
  </div>

  <div id="pauseOverlay" style="display:none;">
    <h2>Pause</h2>
    <button id="resumeBtn">Weiter</button>
  </div>

  <div id="gameOverOverlay" style="display:none; flex-direction: column;">
    <h2>Game Over</h2>
    <p>Highscore:</p>
    <div id="highscores"></div>
    <button id="restartBtn">Neu starten</button>
  </div>
</div>

<div id="info">
  <div>Punkte: <span id="score">0</span></div>
  <div>Level: <span id="level">1</span></div>
</div>

<div id="controls">
  <p><strong>Steuerung:</strong></p>
  <ul>
    <li><strong>PC:</strong> Pfeiltasten ← → ↓ (Block bewegen/fallen lassen), ↑ (drehen), Esc (Pause)</li>
    <li><strong>Touch:</strong> Wischen links/rechts (bewegen), runter (schnell fallen lassen), oben (drehen)</li>
  </ul>
</div>

<script>
(() => {
  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');
  const scoreElem = document.getElementById('score');
  const levelElem = document.getElementById('level');
  const menu = document.getElementById('menu');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const highscoresElem = document.getElementById('highscores');
  const startBtn = document.getElementById('startBtn');
  const resumeBtn = document.getElementById('resumeBtn');
  const restartBtn = document.getElementById('restartBtn');

  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 24;
  const COLORS = [
    null,
    '#00f0f0', // I - cyan
    '#0000f0', // J - blue
    '#f0a000', // L - orange
    '#f0f000', // O - yellow
    '#00f000', // S - green
    '#a000f0', // T - purple
    '#f00000'  // Z - red
  ];

  // Tetrominos as 2D matrices
  const SHAPES = [
    [],
    [[1,1,1,1]],                  // I
    [[2,0,0],[2,2,2]],            // J
    [[0,0,3],[3,3,3]],            // L
    [[4,4],[4,4]],                // O
    [[0,5,5],[5,5,0]],            // S
    [[0,6,0],[6,6,6]],            // T
    [[7,7,0],[0,7,7]]             // Z
  ];

  // Game state
  let arena = createMatrix(COLS, ROWS);
  let dropCounter = 0;
  let dropInterval = 1000; // in ms, will speed up with levels
  let lastTime = 0;
  let gameOver = false;
  let paused = false;
  let score = 0;
  let level = 1;

  // Current piece
  let player = {
    pos: {x:0, y:0},
    matrix: null,
    score: 0,
  };

  // Touch handling variables
  let touchStartX = null;
  let touchStartY = null;
  let touchStartTime = 0;

  // Highscore
  function loadHighscores() {
    const scores = localStorage.getItem('tetrisHighscores');
    return scores ? JSON.parse(scores) : [];
  }
  function saveHighscores(scores) {
    localStorage.setItem('tetrisHighscores', JSON.stringify(scores));
  }
  function addHighscore(score) {
    let scores = loadHighscores();
    scores.push(score);
    scores.sort((a,b) => b - a);
    if(scores.length > 10) scores = scores.slice(0,10);
    saveHighscores(scores);
  }
  function showHighscores() {
    const scores = loadHighscores();
    if(scores.length === 0) {
      highscoresElem.textContent = 'Keine Einträge';
      return;
    }
    highscoresElem.innerHTML = '<ol>' + scores.map(s => `<li>${s}</li>`).join('') + '</ol>';
  }

  // Utility functions
  function createMatrix(w,h) {
    const matrix = [];
    for(let i=0; i<h; i++) {
      matrix.push(new Array(w).fill(0));
    }
    return matrix;
  }

  function collide(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for(let y=0; y<m.length; ++y) {
      for(let x=0; x<m[y].length; ++x) {
        if(m[y][x] !== 0 &&
          (arena[y + o.y] &&
           arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function merge(arena, player) {
    const m = player.matrix;
    const o = player.pos;
    for(let y=0; y<m.length; ++y) {
      for(let x=0; x<m[y].length; ++x) {
        if(m[y][x] !== 0) {
          arena[y + o.y][x + o.x] = m[y][x];
        }
      }
    }
  }

  function rotate(matrix, dir) {
    for(let y=0; y<matrix.length; ++y) {
      for(let x=0; x<y; ++x) {
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir > 0) {
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function playerReset() {
    const pieces = 'TJLOSZI';
    const index = Math.floor(Math.random() * pieces.length) + 1;
    player.matrix = SHAPES[index];
    player.pos.y = 0;
    player.pos.x = Math.floor(COLS/2) - Math.floor(player.matrix[0].length/2);

    if(collide(arena, player)) {
      gameOver = true;
      showGameOver();
    }
  }

  function playerMove(dir) {
    player.pos.x += dir;
    if(collide(arena, player)) {
      player.pos.x -= dir;
    }
  }

  function playerDrop() {
    player.pos.y++;
    if(collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      sweepArena();
      playerReset();
    }
    dropCounter = 0;
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    rotate(player.matrix, dir);
    if(collide(arena, player)) {
      player.pos.x = pos;
      rotate(player.matrix, -dir);
    }
  }

  function sweepArena() {
    let rowCount = 1;
    outer: for(let y=arena.length -1; y>=0; --y) {
      for(let x=0; x<arena[y].length; ++x) {
        if(arena[y][x] === 0) {
          continue outer;
        }
      }
      // row full
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      score += rowCount * 10;
      rowCount *= 2;
    }
    updateScoreLevel();
  }

  function updateScoreLevel() {
    scoreElem.textContent = score;
    const newLevel = Math.min(100, Math.floor(score / 1000) + 1);
    if(newLevel !== level) {
      level = newLevel;
      dropInterval = Math.max(100, 1000 - (level - 1) * 10);
      levelElem.textContent = level;
    }
  }

  function drawMatrix(matrix, offset) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value !== 0) {
          ctx.fillStyle = COLORS[value];
          ctx.fillRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          ctx.strokeStyle = '#222';
          ctx.lineWidth = 2;
          ctx.strokeRect((x + offset.x) * BLOCK_SIZE, (y + offset.y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      });
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawMatrix(arena, {x:0, y:0});
    drawMatrix(player.matrix, player.pos);
  }

  function update(time = 0) {
    if(gameOver || paused) {
      lastTime = time;
      requestAnimationFrame(update);
      return;
    }
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    if(dropCounter > dropInterval) {
      playerDrop();
    }
    draw();
    requestAnimationFrame(update);
  }

  // Event handlers for keyboard
  document.addEventListener('keydown', event => {
    if(gameOver || paused) return;

    switch(event.key) {
      case 'ArrowLeft':
        playerMove(-1);
        break;
      case 'ArrowRight':
        playerMove(1);
        break;
      case 'ArrowDown':
        playerDrop();
        break;
      case 'ArrowUp':
        playerRotate(1);
        break;
      case 'Escape':
        togglePause();
        break;
    }
  });

  // Touch control
  canvas.addEventListener('touchstart', e => {
    if(gameOver || paused) return;
    if(e.touches.length !== 1) return;
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchStartTime = e.timeStamp;
  });

  canvas.addEventListener('touchend', e => {
    if(gameOver || paused) return;
    if(touchStartX === null || touchStartY === null) return;

    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;

    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);

    // Minimaler Swipe Abstand
    const threshold = 30;

    if(absDx > absDy && absDx > threshold) {
      // Horizontal swipe
      if(dx > 0) playerMove(1);
      else playerMove(-1);
    } else if(absDy > absDx && absDy > threshold) {
      // Vertical swipe
      if(dy > 0) playerDrop();
      else playerRotate(1);
    }

    touchStartX = null;
    touchStartY = null;
  });

  // Start, Pause, Restart
  startBtn.onclick = () => {
    startGame();
  };

  resumeBtn.onclick = () => {
    togglePause();
  };

  restartBtn.onclick = () => {
    resetGame();
  };

  function startGame() {
    arena = createMatrix(COLS, ROWS);
    score = 0;
    level = 1;
    dropInterval = 1000;
    gameOver = false;
    paused = false;
    playerReset();
    updateScoreLevel();
    menu.style.display = 'none';
    pauseOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    update();
  }

  function togglePause() {
    if(gameOver) return;
    paused = !paused;
    pauseOverlay.style.display = paused ? 'flex' : 'none';
  }

  function resetGame() {
    gameOver = false;
    paused = false;
    score = 0;
    level = 1;
    dropInterval = 1000;
    arena = createMatrix(COLS, ROWS);
    playerReset();
    updateScoreLevel();
    gameOverOverlay.style.display = 'none';
    menu.style.display = 'none';
    pauseOverlay.style.display = 'none';
    update();
  }

  function showGameOver() {
    addHighscore(score);
    showHighscores();
    gameOverOverlay.style.display = 'flex';
  }

  // Initial setup
  menu.style.display = 'flex';
  pauseOverlay.style.display = 'none';
  gameOverOverlay.style.display = 'none';

})();
</script>
</body>
</html>
