<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Tetris</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #111;
      color: white;
      font-family: sans-serif;
      display: flex; flex-direction: column; align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      image-rendering: pixelated;
      background: #000;
      border: 2px solid white;
      touch-action: none;
      display: none;
      width: 240px; /* 10 * 24 */
      height: 480px; /* 20 * 24 */
    }
    #menu, #pauseOverlay, #gameOverOverlay {
      position: absolute;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 20px;
      text-align: center;
      border: 2px solid white;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
    }
    #info {
      margin-top: 10px;
    }
    #controls {
      margin-top: 10px;
      max-width: 300px;
      text-align: center;
      font-size: 14px;
    }
    #highscores {
      max-height: 150px;
      overflow-y: auto;
      margin-top: 10px;
      text-align: left;
    }
  </style>
</head>
<body>
  <h1>Tetris</h1>

  <div id="menu">
    <h2>Startmenü</h2>
    <button onclick="startGame()">Spiel Starten</button>
  </div>

  <canvas id="tetris" width="240" height="480"></canvas>

  <div id="info">
    Punkte: <span id="score">0</span> | Level: <span id="level">1</span>
  </div>

  <div id="controls">
    <p><strong>Steuerung:</strong></p>
    <ul>
      <li><strong>Touch:</strong> Wischen → bewegen, unten → schneller fallen, oben → drehen</li>
      <li><strong>PC:</strong> Pfeiltasten ← → ↓ ↑</li>
      <li><strong>Esc:</strong> Pause / Fortsetzen</li>
    </ul>
  </div>

  <div id="pauseOverlay" style="display:none;">
    <h2>Pause</h2>
    <button onclick="togglePause()">Weiter</button>
  </div>

  <div id="gameOverOverlay" style="display:none;">
    <h2>Game Over</h2>
    <p>Highscore:</p>
    <div id="highscores"></div>
    <button onclick="restartGame()">Neu starten</button>
  </div>

<script>
(() => {
  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');

  const scoreElem = document.getElementById('score');
  const levelElem = document.getElementById('level');
  const menu = document.getElementById('menu');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const highscoresElem = document.getElementById('highscores');

  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 24;

  canvas.style.display = 'none';

  // Spielzustand
  let dropCounter = 0;
  let dropInterval = 1000; // 1 Sekunde pro Zeile
  let lastTime = 0;
  let paused = false;
  let gameOver = false;

  // Spielfeld (Matrix ROWSxCOLS)
  let arena = createMatrix(COLS, ROWS);

  // Spielerobjekt
  let player = {
    pos: {x: 0, y: 0},
    matrix: null,
    score: 0,
    level: 1,
    lines: 0,
  };

  // Tetris Figuren mit Farbindex (1..7)
  const tetrominoes = {
    'T': [
      [0, 1, 0],
      [1, 1, 1],
      [0, 0, 0]
    ],
    'O': [
      [2, 2],
      [2, 2]
    ],
    'L': [
      [0, 0, 3],
      [3, 3, 3],
      [0, 0, 0]
    ],
    'J': [
      [4, 0, 0],
      [4, 4, 4],
      [0, 0, 0]
    ],
    'I': [
      [0, 0, 0, 0],
      [5, 5, 5, 5],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ],
    'S': [
      [0, 6, 6],
      [6, 6, 0],
      [0, 0, 0]
    ],
    'Z': [
      [7, 7, 0],
      [0, 7, 7],
      [0, 0, 0]
    ],
  };

  // Farben passend zu Farbindex
  const colors = [
    null,
    '#FF0D72', // T - pink
    '#FF8E0D', // O - orange
    '#FFD700', // L - gold
    '#1E90FF', // J - dodger blue
    '#00FFFF', // I - cyan
    '#00FF00', // S - lime green
    '#FF0000'  // Z - red
  ];

  // Hilfsfunktionen

  function createMatrix(w, h){
    const matrix = [];
    for(let i=0; i<h; i++){
      matrix.push(new Array(w).fill(0));
    }
    return matrix;
  }

  function drawMatrix(matrix, offset){
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value !== 0){
          ctx.fillStyle = colors[value];
          ctx.fillRect((x + offset.x)*BLOCK_SIZE, (y + offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
          ctx.strokeStyle = '#111';
          ctx.lineWidth = 2;
          ctx.strokeRect((x + offset.x)*BLOCK_SIZE, (y + offset.y)*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      });
    });
  }

  function merge(arena, player){
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value !== 0){
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function collide(arena, player){
    for(let y=0; y<player.matrix.length; y++){
      for(let x=0; x<player.matrix[y].length; x++){
        if(player.matrix[y][x] !== 0){
          if(!arena[y + player.pos.y] || arena[y + player.pos.y][x + player.pos.x] !== 0){
            return true;
          }
        }
      }
    }
    return false;
  }

  function rotate(matrix, dir){
    // Transpose
    for(let y=0; y<matrix.length; y++){
      for(let x=0; x<y; x++){
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    // Reverse rows oder columns je nach Richtung
    if(dir > 0){
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  // Player reset - neuer Block
  function playerReset(){
    const pieces = 'TJLOSZI';
    player.matrix = tetrominoes[pieces[Math.floor(Math.random() * pieces.length)]];
    player.pos.y = 0;
    player.pos.x = Math.floor((COLS - player.matrix[0].length) / 2);

    if(collide(arena, player)){
      // Spiel Ende
      gameOver = true;
      showGameOver();
    }
  }

  function playerDrop(){
    player.pos.y++;
    if(collide(arena, player)){
      player.pos.y--;
      merge(arena, player);
      arenaSweep();
      playerReset();
    }
    dropCounter = 0;
  }

  function playerMove(dir){
    player.pos.x += dir;
    if(collide(arena, player)){
      player.pos.x -= dir;
    }
  }

  function playerRotate(dir){
    const posX = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while(collide(arena, player)){
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if(offset > player.matrix[0].length){
        rotate(player.matrix, -dir);
        player.pos.x = posX;
        return;
      }
    }
  }

  function arenaSweep(){
    let rowCount = 0;
    outer: for(let y=arena.length - 1; y>=0; y--){
      for(let x=0; x<arena[y].length; x++){
        if(arena[y][x] === 0){
          continue outer;
        }
      }
      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      y++;
      rowCount++;
    }
    if(rowCount > 0){
      // Punkte
      const pointsByLines = [0, 40, 100, 300, 1200];
      player.score += pointsByLines[rowCount] * player.level;
      player.lines += rowCount;
      // Level erhöhen alle 10 Linien
      if(player.lines >= player.level * 10){
        player.level++;
        // Fallgeschwindigkeit erhöhen (max 100ms minimal)
        dropInterval = Math.max(100, 1000 - (player.level - 1) * 100);
      }
      updateScore();
    }
  }

  function updateScore(){
    scoreElem.textContent = player.score;
    levelElem.textContent = player.level;
  }

  function draw(){
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawMatrix(arena, {x:0,y:0});
    drawMatrix(player.matrix, player.pos);
  }

  function update(time = 0){
    if(paused || gameOver){
      lastTime = time;
      requestAnimationFrame(update);
      return;
    }
    const deltaTime = time - lastTime;
    lastTime = time;

    dropCounter += deltaTime;
    if(dropCounter > dropInterval){
      playerDrop();
      dropCounter = 0;
    }

    draw();
    requestAnimationFrame(update);
  }

  // Steuerung

  window.addEventListener('keydown', event => {
    if(gameOver) return;
    if(event.key === 'ArrowLeft'){
      playerMove(-1);
    } else if(event.key === 'ArrowRight'){
      playerMove(1);
    } else if(event.key === 'ArrowDown'){
      playerDrop();
    } else if(event.key === 'ArrowUp'){
      playerRotate(1);
    } else if(event.key === 'Escape'){
      togglePause();
    }
  });

  // Touchsteuerung (einfaches Wischen)
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  let moved = false;

  canvas.addEventListener('touchstart', e => {
    if(gameOver) return;
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchStartTime = Date.now();
    moved = false;
  });

  canvas.addEventListener('touchmove', e => {
    if(gameOver) return;
    if(moved) return;
    const touch = e.touches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;

    if(Math.abs(dx) > 30 && Math.abs(dx) > Math.abs(dy)){
      if(dx > 0){
        playerMove(1);
      } else {
        playerMove(-1);
      }
      moved = true;
    } else if(Math.abs(dy) > 30 && Math.abs(dy) > Math.abs(dx)){
      if(dy > 0){
        // Schneller fallen lassen
        playerDrop();
      } else {
        // Drehen
        playerRotate(1);
      }
      moved = true;
    }
  });

  canvas.addEventListener('touchend', e => {
    moved = false;
  });

  // Game Funktionen

  function startGame(){
    arena = createMatrix(COLS, ROWS);
    player.score = 0;
    player.level = 1;
    player.lines = 0;
    dropInterval = 1000;
    dropCounter = 0;
    gameOver = false;
    paused = false;

    updateScore();
    playerReset();

    menu.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    pauseOverlay.style.display = 'none';

    canvas.style.display = 'block';

    lastTime = 0;
    requestAnimationFrame(update);
  }

  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    pauseOverlay.style.display = paused ? 'block' : 'none';
    if(!paused){
      lastTime = performance.now();
      requestAnimationFrame(update);
    }
  }

  function showGameOver(){
    canvas.style.display = 'none';
    gameOverOverlay.style.display = 'block';
    menu.style.display = 'none';
    pauseOverlay.style.display = 'none';

    saveHighscore(player.score);
    displayHighscores();
  }

  // Highscore Funktionen

  function saveHighscore(score){
    let scores = JSON.parse(localStorage.getItem('tetrisHighscores') || '[]');
    scores.push(score);
    scores.sort((a,b) => b - a);
    if(scores.length > 10) scores.length = 10;
    localStorage.setItem('tetrisHighscores', JSON.stringify(scores));
  }

  function displayHighscores(){
    let scores = JSON.parse(localStorage.getItem('tetrisHighscores') || '[]');
    highscoresElem.innerHTML = '';
    if(scores.length === 0){
      highscoresElem.textContent = 'Keine Einträge';
      return;
    }
    const ul = document.createElement('ul');
    scores.forEach((s, i) => {
      const li = document.createElement('li');
      li.textContent = `${i+1}. ${s} Punkte`;
      ul.appendChild(li);
    });
    highscoresElem.appendChild(ul);
  }

  function restartGame(){
    startGame();
  }

  // Startmenü anzeigen beim Laden
  menu.style.display = 'block';

  // Initial keine Highscores anzeigen
  highscoresElem.textContent = 'Keine Einträge';
})();
</script>

</body>
</html>
