<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Tetris</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      background: #111;
      color: white;
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      image-rendering: pixelated;
      background: black;
      border: 2px solid white;
      touch-action: none;
      max-width: calc(24px * 10);
      max-height: calc(24px * 20);
      width: 100vw;
      max-width: 240px;
      height: auto;
    }
    #info {
      margin-top: 10px;
    }
    #menu, #pauseOverlay, #gameOverOverlay {
      position: absolute;
      background: rgba(0,0,0,0.9);
      color: white;
      padding: 20px;
      text-align: center;
      border: 2px solid white;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      max-width: 300px;
      border-radius: 8px;
    }
    #highscores {
      margin-top: 10px;
      max-height: 150px;
      overflow-y: auto;
      text-align: left;
      font-family: monospace;
    }
    #levelInfo {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border: 2px solid white;
      font-size: 16px;
      border-radius: 5px;
      user-select: none;
      z-index: 5;
    }
    #controls {
      margin-top: 10px;
      text-align: center;
      max-width: 300px;
      font-size: 14px;
      user-select: none;
    }
  </style>
</head>
<body>
  <h1>Tetris</h1>

  <div id="menu">
    <h2>Startmenü</h2>
    <button onclick="startGame()">Spiel Starten</button>
  </div>

  <canvas id="tetris"></canvas>

  <div id="info">
    <p>Punkte: <span id="score">0</span> | Level: <span id="level">1</span></p>
  </div>

  <div id="controls">
    <p><strong>Steuerung:</strong></p>
    <ul>
      <li><strong>Touch:</strong> Wischen → bewegen, unten → fallen lassen, kurz tippen → drehen</li>
      <li><strong>PC:</strong> Pfeiltasten ← → ↓ ↑</li>
      <li><strong>Esc:</strong> Pause / Fortsetzen</li>
    </ul>
  </div>

  <div id="pauseOverlay" style="display:none;">
    <h2>Pause</h2>
    <button onclick="togglePause()">Weiter</button>
  </div>

  <div id="gameOverOverlay" style="display:none;">
    <h2>Game Over</h2>
    <p>Highscore:</p>
    <div id="highscores"></div>
    <button onclick="restartGame()">Neu starten</button>
  </div>

  <div id="levelInfo" style="display:none;">Level 1</div>

<script>
(() => {
  const canvas = document.getElementById('tetris');
  const ctx = canvas.getContext('2d');
  const menu = document.getElementById('menu');
  const pauseOverlay = document.getElementById('pauseOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const highscoresDiv = document.getElementById('highscores');
  const scoreElem = document.getElementById('score');
  const levelElem = document.getElementById('level');
  const levelInfo = document.getElementById('levelInfo');

  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 24;

  canvas.width = COLS * BLOCK_SIZE;
  canvas.height = ROWS * BLOCK_SIZE;

  // Farben (Index 0 nicht benutzt)
  const COLORS = [
    null,
    '#FF0D72', // T
    '#0DC2FF', // I
    '#0DFF72', // S
    '#F538FF', // Z
    '#FF8E0D', // L
    '#FFE138', // O
    '#3877FF'  // J
  ];

  // Formen mit IDs 1-7
  const SHAPES = [
    [],
    [[0,1,0],[1,1,1],[0,0,0]],           // T
    [[1,1,1,1]],                         // I
    [[0,1,1],[1,1,0],[0,0,0]],           // S
    [[1,1,0],[0,1,1],[0,0,0]],           // Z
    [[1,0,0],[1,1,1],[0,0,0]],           // L
    [[1,1],[1,1]],                       // O
    [[0,0,1],[1,1,1],[0,0,0]]            // J
  ];

  let arena;
  let player;
  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;
  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let paused = false;
  let gameOver = false;

  // Hilfsfunktion: Matrix erstellen (leer)
  function createMatrix(w, h){
    const matrix = [];
    while(h--) matrix.push(new Array(w).fill(0));
    return matrix;
  }

  // Prüfen auf Kollision
  function collide(arena, player){
    const [m, o] = [player.matrix, player.pos];
    for(let y=0; y < m.length; y++){
      for(let x=0; x < m[y].length; x++){
        if(m[y][x] !== 0 &&
          (arena[y+o.y] && arena[y+o.y][x+o.x]) !== 0){
          return true;
        }
      }
    }
    return false;
  }

  // Matrix zeichnen
  function drawMatrix(matrix, offset, isPlayer = false){
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value !== 0){
          ctx.fillStyle = isPlayer ? COLORS[player.color] : COLORS[value];
          ctx.fillRect((x + offset.x)*BLOCK_SIZE, (y + offset.y)*BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE -1);
        }
      });
    });
  }

  // Zeichenfunktion
  function draw(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    drawMatrix(arena, {x:0,y:0}, false);
    drawMatrix(player.matrix, player.pos, true);
  }

  // Spielstand aktualisieren
  function updateScore(){
    scoreElem.textContent = score;
    levelElem.textContent = level;
  }

  // Spieler zurücksetzen (neuer Stein)
  function resetPlayer(){
    const pieces = 'TISZLOJ';
    const randIndex = Math.floor(Math.random()*pieces.length) +1;
    player.matrix = SHAPES[randIndex].map(row => [...row]);
    player.pos = {x: Math.floor(COLS/2) - Math.floor(player.matrix[0].length/2), y: 0};
    player.color = randIndex;
    if(collide(arena, player)){
      gameOver = true;
      showGameOver();
    }
  }

  // Stein drehen
  function rotate(matrix, dir){
    for(let y=0; y < matrix.length; y++){
      for(let x=0; x < y; x++){
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir > 0){
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function playerRotate(dir = 1){
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while(collide(arena, player)){
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if(offset > player.matrix[0].length){
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
  }

  // Stein fallen lassen
  function playerDrop(){
    player.pos.y++;
    if(collide(arena, player)){
      player.pos.y--;
      merge(arena, player);
      const lines = arenaSweep();
      if(lines > 0){
        score += calculateScore(lines);
        linesCleared += lines;
        updateLevel();
        updateScore();
      }
      resetPlayer();
      dropCounter = 0;
    }
  }

  // Stein nach links/rechts bewegen
  function playerMove(dir){
    player.pos.x += dir;
    if(collide(arena, player)){
      player.pos.x -= dir;
    }
  }

  // Arena mit Player verschmelzen
  function merge(arena, player){
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if(value !== 0){
          arena[y + player.pos.y][x + player.pos.x] = player.color;
        }
      });
    });
  }

  // Linien entfernen & zählen
  function arenaSweep(){
    let rowCount = 0;
    outer: for(let y = arena.length -1; y >= 0; y--){
      for(let x = 0; x < arena[y].length; x++){
        if(arena[y][x] === 0) continue outer;
      }
      const row = arena.splice(y,1)[0].fill(0);
      arena.unshift(row);
      y++;
      rowCount++;
    }
    return rowCount;
  }

  // Punkte berechnen
  function calculateScore(lines){
    const lineScores = [0,40,100,300,1200];
    return lineScores[lines] * level;
  }

  // Level aktualisieren (alle 10 Linien)
  function updateLevel(){
    const newLevel = Math.floor(linesCleared / 10) + 1;
    if(newLevel > level){
      level = newLevel;
      dropInterval = Math.max(100, 1000 - (level -1) * 100);
      levelInfo.textContent = 'Level ' + level;
      showLevelInfo();
      updateScore();
    }
  }

  // Levelanzeige kurz anzeigen
  let levelInfoTimeout;
  function showLevelInfo(){
    levelInfo.style.display = 'block';
    clearTimeout(levelInfoTimeout);
    levelInfoTimeout = setTimeout(() => {
      levelInfo.style.display = 'none';
    }, 1500);
  }

  // Game Over anzeigen
  function showGameOver(){
    menu.style.display = 'none';
    pauseOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'block';
    saveHighscore();
    showHighscores();
  }

  // Highscore speichern (localStorage)
  function saveHighscore(){
    const highscores = JSON.parse(localStorage.getItem('tetrisHighscores')) || [];
    highscores.push({score, level, date: new Date().toISOString()});
    highscores.sort((a,b) => b.score - a.score);
    if(highscores.length > 10) highscores.length = 10;
    localStorage.setItem('tetrisHighscores', JSON.stringify(highscores));
  }

  // Highscores anzeigen
  function showHighscores(){
    const highscores = JSON.parse(localStorage.getItem('tetrisHighscores')) || [];
    highscoresDiv.innerHTML = '';
    if(highscores.length === 0){
      highscoresDiv.textContent = 'Keine Highscores vorhanden.';
      return;
    }
    highscores.forEach((entry, i) => {
      const d = new Date(entry.date);
      highscoresDiv.innerHTML += 
        `${i+1}. Score: ${entry.score} | Level: ${entry.level} | ${d.toLocaleDateString()}<br>`;
    });
  }

  // Spiel starten
  function startGame(){
    arena = createMatrix(COLS, ROWS);
    player = {
      pos: {x:0, y:0},
      matrix: null,
      color: 0
    };
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 1000;
    paused = false;
    gameOver = false;
    updateScore();
    resetPlayer();
    menu.style.display = 'none';
    pauseOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    levelInfo.style.display = 'none';
    canvas.style.display = 'block';
    lastTime = 0;
    dropCounter = 0;
    update();
  }

  // Spiel neu starten nach Game Over
  function restartGame(){
    startGame();
  }

  // Pause umschalten
  function togglePause(){
    if(gameOver) return;
    paused = !paused;
    if(paused){
      pauseOverlay.style.display = 'block';
      levelInfo.style.display = 'none';
    } else {
      pauseOverlay.style.display = 'none';
      lastTime = performance.now();
      update();
    }
  }

  // Haupt-Update-Loop
  function update(time = 0){
    if(gameOver || paused) return;
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;

    if(dropCounter > dropInterval){
      playerDrop();
    }
    draw();
    requestAnimationFrame(update);
  }

  // Touchsteuerung (Wischen)
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  let touchLastMove = 0;

  canvas.addEventListener('touchstart', e => {
    if(gameOver || paused) return;
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
    touchStartTime = Date.now();
    touchLastMove = Date.now();
  }, {passive:true});

  canvas.addEventListener('touchmove', e => {
    if(gameOver || paused) return;
    e.preventDefault();
    const touch = e.touches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;
    const now = Date.now();

    // Sensibilität: 30px horizontal für Bewegung, 40px vertikal für fallen/schneller bewegen
    if(Math.abs(dx) > 30 && (now - touchLastMove) > 100){
      if(dx > 0){
        playerMove(1);
      } else {
        playerMove(-1);
      }
      touchLastMove = now;
      touchStartX = touch.clientX; // reset Start X um schnelleres mehrfaches bewegen zu ermöglichen
    }

    if(dy > 40 && (now - touchLastMove) > 50){
      // schneller fallen lassen
      playerDrop();
      touchLastMove = now;
      touchStartY = touch.clientY; // reset Start Y
    }
  }, {passive:false});

  canvas.addEventListener('touchend', e => {
    if(gameOver || paused) return;
    const touchDuration = Date.now() - touchStartTime;
    // Kurzer Tipp = drehen
    if(touchDuration < 200){
      playerRotate(1);
    }
  }, {passive:true});

  // Tastatur-Steuerung
  document.addEventListener('keydown', e => {
    if(gameOver) return;
    if(e.key === 'ArrowLeft'){
      playerMove(-1);
    } else if(e.key === 'ArrowRight'){
      playerMove(1);
    } else if(e.key === 'ArrowDown'){
      playerDrop();
    } else if(e.key === 'ArrowUp'){
      playerRotate(1);
    } else if(e.key === 'Escape'){
      togglePause();
    }
  });

  // Expose Funktionen global
  window.startGame = startGame;
  window.togglePause = togglePause;
  window.restartGame = restartGame;

})();
</script>

</body>
</html>
